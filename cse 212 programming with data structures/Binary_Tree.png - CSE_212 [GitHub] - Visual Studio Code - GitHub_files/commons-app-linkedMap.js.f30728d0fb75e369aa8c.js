"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[155],{77525:(t,i)=>{var e;Object.defineProperty(i,"__esModule",{value:!0}),i.LRUCache=i.LinkedMap=i.Touch=void 0,function(t){t.None=0,t.First=1,t.AsOld=t.First,t.Last=2,t.AsNew=t.Last}(e=i.Touch||(i.Touch={}));class s{constructor(){this[Symbol.toStringTag]="LinkedMap",this._map=new Map,this._head=void 0,this._tail=void 0,this._size=0,this._state=0}clear(){this._map.clear(),this._head=void 0,this._tail=void 0,this._size=0,this._state++}isEmpty(){return!this._head&&!this._tail}get size(){return this._size}get first(){var t;return null===(t=this._head)||void 0===t?void 0:t.value}get last(){var t;return null===(t=this._tail)||void 0===t?void 0:t.value}has(t){return this._map.has(t)}get(t,i=e.None){const s=this._map.get(t);if(s)return i!==e.None&&this.touch(s,i),s.value}set(t,i,s=e.None){let h=this._map.get(t);if(h)h.value=i,s!==e.None&&this.touch(h,s);else{switch(h={key:t,value:i,next:void 0,previous:void 0},s){case e.None:this.addItemLast(h);break;case e.First:this.addItemFirst(h);break;case e.Last:default:this.addItemLast(h)}this._map.set(t,h),this._size++}return this}delete(t){return!!this.remove(t)}remove(t){const i=this._map.get(t);if(i)return this._map.delete(t),this.removeItem(i),this._size--,i.value}shift(){if(!this._head&&!this._tail)return;if(!this._head||!this._tail)throw new Error("Invalid list");const t=this._head;return this._map.delete(t.key),this.removeItem(t),this._size--,t.value}forEach(t,i){const e=this._state;let s=this._head;for(;s;){if(i?t.bind(i)(s.value,s.key,this):t(s.value,s.key,this),this._state!==e)throw new Error("LinkedMap got modified during iteration.");s=s.next}}keys(){const t=this,i=this._state;let e=this._head;const s={[Symbol.iterator]:()=>s,next(){if(t._state!==i)throw new Error("LinkedMap got modified during iteration.");if(e){const t={value:e.key,done:!1};return e=e.next,t}return{value:void 0,done:!0}}};return s}values(){const t=this,i=this._state;let e=this._head;const s={[Symbol.iterator]:()=>s,next(){if(t._state!==i)throw new Error("LinkedMap got modified during iteration.");if(e){const t={value:e.value,done:!1};return e=e.next,t}return{value:void 0,done:!0}}};return s}entries(){const t=this,i=this._state;let e=this._head;const s={[Symbol.iterator]:()=>s,next(){if(t._state!==i)throw new Error("LinkedMap got modified during iteration.");if(e){const t={value:[e.key,e.value],done:!1};return e=e.next,t}return{value:void 0,done:!0}}};return s}[Symbol.iterator](){return this.entries()}trimOld(t){if(t>=this.size)return;if(0===t)return void this.clear();let i=this._head,e=this.size;for(;i&&e>t;)this._map.delete(i.key),i=i.next,e--;this._head=i,this._size=e,i&&(i.previous=void 0),this._state++}addItemFirst(t){if(this._head||this._tail){if(!this._head)throw new Error("Invalid list");t.next=this._head,this._head.previous=t}else this._tail=t;this._head=t,this._state++}addItemLast(t){if(this._head||this._tail){if(!this._tail)throw new Error("Invalid list");t.previous=this._tail,this._tail.next=t}else this._head=t;this._tail=t,this._state++}removeItem(t){if(t===this._head&&t===this._tail)this._head=void 0,this._tail=void 0;else if(t===this._head){if(!t.next)throw new Error("Invalid list");t.next.previous=void 0,this._head=t.next}else if(t===this._tail){if(!t.previous)throw new Error("Invalid list");t.previous.next=void 0,this._tail=t.previous}else{const i=t.next,e=t.previous;if(!i||!e)throw new Error("Invalid list");i.previous=e,e.next=i}t.next=void 0,t.previous=void 0,this._state++}touch(t,i){if(!this._head||!this._tail)throw new Error("Invalid list");if(i===e.First||i===e.Last)if(i===e.First){if(t===this._head)return;const i=t.next,e=t.previous;t===this._tail?(e.next=void 0,this._tail=e):(i.previous=e,e.next=i),t.previous=void 0,t.next=this._head,this._head.previous=t,this._head=t,this._state++}else if(i===e.Last){if(t===this._tail)return;const i=t.next,e=t.previous;t===this._head?(i.previous=void 0,this._head=i):(i.previous=e,e.next=i),t.next=void 0,t.previous=this._tail,this._tail.next=t,this._tail=t,this._state++}}toJSON(){const t=[];return this.forEach(((i,e)=>{t.push([e,i])})),t}fromJSON(t){this.clear();for(const[i,e]of t)this.set(i,e)}}i.LinkedMap=s;i.LRUCache=class extends s{constructor(t,i=1){super(),this._limit=t,this._ratio=Math.min(Math.max(0,i),1)}get limit(){return this._limit}set limit(t){this._limit=t,this.checkTrim()}get ratio(){return this._ratio}set ratio(t){this._ratio=Math.min(Math.max(0,t),1),this.checkTrim()}get(t,i=e.AsNew){return super.get(t,i)}peek(t){return super.get(t,e.None)}set(t,i){return super.set(t,i,e.Last),this.checkTrim(),this}checkTrim(){this.size>this._limit&&this.trimOld(Math.round(this._limit*this._ratio))}}},22299:(t,i)=>{var e;Object.defineProperty(i,"__esModule",{value:!0}),function(t){t.None=0,t.First=1,t.Last=2}(e=i.Touch||(i.Touch={}));i.LinkedMap=class{constructor(){this._map=new Map,this._head=void 0,this._tail=void 0,this._size=0}clear(){this._map.clear(),this._head=void 0,this._tail=void 0,this._size=0}isEmpty(){return!this._head&&!this._tail}get size(){return this._size}has(t){return this._map.has(t)}get(t){const i=this._map.get(t);if(i)return i.value}set(t,i,s=e.None){let h=this._map.get(t);if(h)h.value=i,s!==e.None&&this.touch(h,s);else{switch(h={key:t,value:i,next:void 0,previous:void 0},s){case e.None:this.addItemLast(h);break;case e.First:this.addItemFirst(h);break;case e.Last:default:this.addItemLast(h)}this._map.set(t,h),this._size++}}delete(t){const i=this._map.get(t);return!!i&&(this._map.delete(t),this.removeItem(i),this._size--,!0)}shift(){if(!this._head&&!this._tail)return;if(!this._head||!this._tail)throw new Error("Invalid list");const t=this._head;return this._map.delete(t.key),this.removeItem(t),this._size--,t.value}forEach(t,i){let e=this._head;for(;e;)i?t.bind(i)(e.value,e.key,this):t(e.value,e.key,this),e=e.next}forEachReverse(t,i){let e=this._tail;for(;e;)i?t.bind(i)(e.value,e.key,this):t(e.value,e.key,this),e=e.previous}values(){let t=[],i=this._head;for(;i;)t.push(i.value),i=i.next;return t}keys(){let t=[],i=this._head;for(;i;)t.push(i.key),i=i.next;return t}addItemFirst(t){if(this._head||this._tail){if(!this._head)throw new Error("Invalid list");t.next=this._head,this._head.previous=t}else this._tail=t;this._head=t}addItemLast(t){if(this._head||this._tail){if(!this._tail)throw new Error("Invalid list");t.previous=this._tail,this._tail.next=t}else this._head=t;this._tail=t}removeItem(t){if(t===this._head&&t===this._tail)this._head=void 0,this._tail=void 0;else if(t===this._head)this._head=t.next;else if(t===this._tail)this._tail=t.previous;else{const i=t.next,e=t.previous;if(!i||!e)throw new Error("Invalid list");i.previous=e,e.next=i}}touch(t,i){if(!this._head||!this._tail)throw new Error("Invalid list");if(i===e.First||i===e.Last)if(i===e.First){if(t===this._head)return;const i=t.next,e=t.previous;t===this._tail?(e.next=void 0,this._tail=e):(i.previous=e,e.next=i),t.previous=void 0,t.next=this._head,this._head.previous=t,this._head=t}else if(i===e.Last){if(t===this._tail)return;const i=t.next,e=t.previous;t===this._head?(i.previous=void 0,this._head=i):(i.previous=e,e.next=i),t.next=void 0,t.previous=this._tail,this._tail.next=t,this._tail=t}}}}}]);